;;; datatype.ss

;;; Time-stamp: <2005-01-29 12:58:30 ksm>
;;; (time-stamp generated by emacs:  Type M-x time-stamp anywhere to update)

;;; This is based on the version of 1999-12-13 16:00:24 due to Erik Hilsdale

;;; <2005-01-29 12:57:34 ksm>
;;; Changed from Chez 6.0 print-method to 6.9c record-writer

;;; This is a Chez-specific (version 6.0) implementation of a datatype
;;; system, with automagic generation of anas and catas over the
;;; datatype.

;;; ------------------------------
;;; User interface

;;;(define-datatype Type-name Predicate-name
;;;  (Variant-name (Field-name Predicate-exp) ...) ...)
;;;                    -> defines Variant-name ..., Predicate-name, Type-name
;;;(cases Type-name Exp Clause ...)
;;;(cata Type-name Clause ...)
;;;(ana Type-name (arg ...) Exp)


(eval-when (compile)
  (generate-inspector-information #f)
  (optimize-level 2))

(define-syntax with-capture
  (syntax-rules ()
    [($ context (name ...) exp0 exp1 ...)
     (with-syntax ((name (datum->syntax-object context 'name))
                   ...)
       exp0 exp1 ...)]))

(define-syntax with-values
  (syntax-rules ()
    ((_ Producer Consumer)
     (call-with-values (lambda () Producer) Consumer))))

(module
  ( datatype-transluscent
    (define-datatype
      do-define-datatype
      define-constructor
      syn-err)
    (cases syn-err)
    (cata syn-err)
    (ana syn-err))

(define datatype-transluscent (make-parameter #t))

(define-syntax define-datatype
  (syntax-rules ()
    ((_ . Rest)
     (do-define-datatype . Rest))))

(define-syntax cases
  (syntax-rules ()
    ((_ Type-name Exp Clause ...)
     (let ((v Exp))
       (Type-name 'CASES
         (syn-err (cases Type-name Exp Clause ...)
           "undefined datatype: ~s" Type-name)
         '((cases Type-name Exp Clause ...) v Clause ...))))))

(define-syntax cata
  (syntax-rules ()
    ((_ Type-name Clause ...)
     (Type-name 'CATA
       (syn-err (cata Type-name Clause ...)
         "undefined datatype: ~s" Type-name)
       '((cata Type-name Clause ...)
         Clause ...)))))

(define-syntax ana
  (syntax-rules ()
    ((_ Type-name (formal ...) Body0 Body ...)
     (Type-name 'ANA
       (syn-err (ana Type-name (formal ...) Body0 Body ...)
         "undefined datatype: ~s" Type-name)
       '((ana Type-name (formal ...) Body0 Body ...)
         (formal ...) (begin Body0 Body ...))))))

;;; ------------------------------
;;; datatype definition

;;; this uses an extremely annoying temporary macro to allow this to
;;; be used both at top-level and within stuff.

(define-syntax do-define-datatype
  (syntax-rules ()
    ((_ Type-name Pred-name (Variant-name (Field-name Pred?) ...) ...)
     (begin
       (module ((Type-name dd-rec-variant dd-rec-contents)
                (annoying-invisible-identifier make-dd-rec dd-rec?))
         (define-record dd-rec ((immutable variant) (immutable contents)) ()
           (
;             (print-method
;             (let ((name (format "#<~s>" 'Type-name)))
;               (lambda (r p wr)
;                 (if (datatype-transluscent)
;                     (fprintf p "#<~a:~a>" 'Type-name (dd-rec-variant r))
;                     (display name p)))))
            ))
         (define-syntax annoying-invisible-identifier
           (syntax-rules (make check)
             ((_ make) make-dd-rec)
             ((_ check) dd-rec?)))
         (define-syntax Type-name
           (lambda (x)
             (syntax-case x
                 (Pred-name quote ANA ANA-DISP CATA CASES C-TEST
                   C-CLAUSE UNROLL else ANA-MAP)


               ((_ 'CASES Blah '(Src Var Clause (... ...)))
                #'(let ((tag (dd-rec-variant Var))
                        (contents (dd-rec-contents Var)))
                    (cond
                      ((Type-name 'C-TEST Clause tag)
                       (Type-name 'C-CLAUSE 'CASES Clause ignored-f contents))
                      (... ...))))
               ((_ 'CATA Blah '(Src Clause (... ...)))
                #'(rec f
                    (lambda (x)
                      (let ((tag (dd-rec-variant x))
                            (contents (dd-rec-contents x)))
                        (cond
                          ((Type-name 'C-TEST Clause tag)
                           (Type-name 'C-CLAUSE 'CATA Clause f contents))
                          (... ...))))))

               ((_ 'C-TEST (else Exp . Exps) tag)
                #'#t)
               ((_ 'C-TEST (Var-name Formals Exp . Exps) Tag)
                (equal? (syntax-object->datum #'Var-name)
                  (syntax-object->datum #'Variant-name))
                #'(eq? Tag 'Variant-name))
               ...

               ((_ 'C-CLAUSE Ctype (else Exp . Exps) F Contents)
                #'(begin Exp . Exps))
               ((_ 'C-CLAUSE Ctype (Var-name Formals Exp . Exps) F Contents)
                (equal? (syntax-object->datum #'Var-name)
                  (syntax-object->datum #'Variant-name))
                #'(Type-name 'UNROLL Ctype Formals (Pred? ...) F Contents
                    (begin Exp . Exps)))
               ...

               ((_ 'UNROLL Ctype () () F Contents Body)
                #'Body)
               ((_ 'UNROLL 'CATA (Formals . Restf) (Pred-name . Restp)
                  F V Body)
                #'(let ((t (car V))
                        (V (cdr V)))
                    (with-values (F t)
                      (lambda Formals
                        (Type-name 'UNROLL 'CATA Restf Restp F V Body)))))
               ((_ 'UNROLL XX (Formal . Restf) (YY . Restp) F V Body)
                #'(let ((Formal (car V))
                        (V (cdr V)))
                    (Type-name 'UNROLL XX Restf Restp F V Body)))

               ((_ 'ANA Blah '(Src Formals Body))
                (with-capture #'_ (Variant-name ...)
                  #'(rec f
                      (lambda Formals
                        (let-syntax
                            ((Variant-name
                               (syntax-rules ()
                                 ((_ Arg ((... ...) (... ...)))
                                  (Type-name 'ANA-MAP f Variant-name
                                    (Pred? ...)
                                    (Arg ((... ...) (... ...)))))))
                             ...)
                          Body)))))
               ((_ 'ANA-MAP F Variant (Pred (... ...)) (Arg (... ...)))
                #'(Variant (Type-name 'ANA-DISP F Pred Arg) (... ...)))
               ((_ 'ANA-DISP F Pred-name Arg)
                #'(F . Arg))
               ((_ 'ANA-DISP F Non-recur Arg)
                #'Arg))))
         (record-writer (type-descriptor dd-rec)
           (let ((name (format "#<~s>" 'Type-name)))
             (lambda (r p wr)
               (if (datatype-transluscent)
                   (fprintf p "#<~a:~a>" 'Type-name (dd-rec-variant r))
                   (display name p))))))

       (define Pred-name
         (lambda (x)
           ((annoying-invisible-identifier check) x)))
       (define-constructor Variant-name (annoying-invisible-identifier make)
         (Field-name ...) (Pred? ...))
       ...))))

(define-syntax define-constructor
  (lambda (x)
    (syntax-case x ()
      ((_ Variant-name Maker () ())
       #'(define Variant-name
           (lambda ()
             (let ((variant (Maker 'Variant-name '())))
               (set! Variant-name
                 (lambda () variant))
               variant))))
      ((_ Variant-name Maker (Field-name ...) (Pred ...))
       (with-syntax (((Temp ...) (generate-temporaries #'(Field-name ...))))
         #'(define Variant-name
             (lambda (Temp ...)
               (unless (Pred Temp)
                 (error 'Variant-name "bad ~a field: (~s ~s) => #f"
                   'Field-name 'Pred Temp))
               ...
               (let ((contents (list Temp ...)))
                 (Maker 'Variant-name contents)))))))))

;;; ------------------------------
;;; errors

(define-syntax syn-err
  (lambda (x)
    (syntax-case x ()
      ((_ Src Format-string Arg ...)
       (let ((fs (syntax-object->datum #'Format-string))
             (args (map syntax-object->datum #'(Arg ... Src))))
         (apply error #f (string-append fs "~n  ~a") args))))))

)

(define always?
  (lambda (x) #t))

(define list-of
  (lambda (pred . l)
    (let ((all-preds (cons pred l)))
      (lambda (obj)
        (let loop ((obj obj) (preds '()))
          (or
            ;; if list is empty, preds should be, too
            (and (null? obj) (null? preds))
            (if (null? preds)
                ;; if preds is empty, but list isn't, then recycle
                (loop obj all-preds)
                ;; otherwise check and element and recur.
                (and (pair? obj)
                     ((car preds) (car obj))
                     (loop (cdr obj) (cdr preds))))))))))

(define vector-of
  (lambda (pred)
    (lambda (v)
      (andmap pred (vector->list v)))))

#!eof

(define-datatype Exp exp?
  (Var (id symbol?))
  (Proc (formal symbol?)
    (body exp?)))

(define free+bound
  (cata Exp
    (Var (x) (values (list x) '()))
    (Proc (formal (bodyfree bodybound))
      (values (remove formal bodyfree)
        (append (if (member formal bodyfree)
                    (list formal)
                    '())
          bodybound)))))

(define alpha-subst
  (ana Exp (e env)
    (cases Exp e
      (Var (x) (Var (cond ((assv name env) => cdr) (else name))))
      (Proc (formal body)
        (Proc formal [body (cons (formal formal) env)])))))

(define-datatype Lyst lyst?
  (Nil)
  (Pair (head integer?) (tail lyst?)))

(define make-list
   (ana Lyst (n)
     (if (zero? n)
         (Nil)
         (Pair 3 [(sub1 n)]))))

